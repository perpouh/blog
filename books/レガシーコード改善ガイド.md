
[Amazon](https://amzn.to/4l9uLPO)

## 第一部 変更のメカニズム

### 第1章 ソフトウェアの変更

 - 1.1ソフトウェア変更の四つの理由

	 - 1.1.1 要件の追加とバグの修正
	 - 1.1.2 設計の改善
	 - 1.1.3 リソース利用の最適化
	 - 1.1.4 四つの変更理由のまとめ
 - 1.2 危険な変更

### 第2章 フィードバックを得ながらの作業

 - 2.1 単体テストとは
 - 2.2上位レベルのテスト
 - 2.3 テストによる保護
 - 2.4 レガシーコードの変更手順
	 - 2.4.1 変更点を洗い出す
	 - 2.4.2 テストを書く場所を見つける
	 - 2.4.3 依存関係を排除する
	 - 2.4.4 テストを書く
	 - 2.4.5 変更とリファクタリングを行う
	 - 2.4.6 この後の内容

### 第3章 検出と分離
 - 3.1 協調クラスの擬装
	 - 3.1.1 擬装オプジェクト
	 - 3.1.2 擬装オブジェクトの2つの側面
	 - 3.1.3 擬装のエッセンス
	 - 3.1.4 モックオブジェクト

### 第4章 接合モデル
 - 4.1 巨大な用紙の文字の羅列
 - 4.2 接合部
 - 4.3 接合部の種類
	 - 4.3.1 プリプロセッサ接合部
	 - 4.3.2 リンク接合部
	 - 4.3.3 オブジェクト接合部

### 第5章 ツール
 - 5.1 自動リファクタリングツール
 - 5.2 モックオブジェクト
 - 5.3 単体テストハーネス
	 - 5.3.1 JUnit
	 - 5.3.2 CppUnitLite
	 - 5.3.3 NUnit
	 - 5.3.4 その他のxUnitフレームワーク
 - 5.4 一般的なテストハーネス
	 - 5.4.1 FIT
	 - 5.4.2 Fitnesse

## 第2部 ソフトウェアの変更

### 第6章時間がないのに変更しなければなりません
 - 6.1 スプラウトメソッド
	 - 6.1.1 長所と短所
 - 6.2 スプラウトクラス
	 - 6.2.1 長所と短所
 - 6.3 ラップメソッド
	 - 6.3.1 長所と短所
 - 6.4 ラップクラス
 - 6.5 まとめ

### 第7章 いつまで経っても変更作業が終わりません
 - 7.1 理解すること
 - 7.2 遅延時間…
 - 7.3 依存関係の排除
	 - 7.3.1 ビルドの依存関係
 - 7.4 まとめ

### 第8章 どうやって機能を追加すればよいのでしょうか？
 - 8.1 テスト駆動開発（TDD）
	 - 8.1.1 失敗するテストケースを記述する
	 - 8.1.2 コンパイルする
	 - 8.1.3 テストを通過させる
	 - 8.1.4 重複を取り除く
	 - 8.1.5 失敗するテストケースを記述する
	 - 8.1.6 コンパイルする
	 - 8.1.7 テストを通過させる
	 - 8.1.8 重複を取り除く
	 - 8.1.9 失敗するテストケースを記述する
	 - 8.1.10 コンパイルする
	 - 8.1.11 テストを通過させる
	 - 8.1.12 重複を取り除く
 - 8.2 差分プログラミング
 - 8.3 まとめ

### 第9章 このクラスをテストハーネスに入れることができません
 - 9.1 いらだたしいパラメータ
 - 9.2 隠れた依存関係
 - 9.3 複雑な生成
 - 9.4 いらだたしいグローバルな依存関係
 - 9.5 恐るべきインクルードの依存関係
 - 9.6 玉ねぎパラメータ
 - 9.7 別名のパラメータ

### 第10章 このメソッドをテストハーネスで動かすことができません

 - 10.1 隠れたメソッド
 - 10.2 言語の「便利な」機能
 - 10.3 検出できない副作用

### 第11章 変更する必要がありますが、どのメソッドをテストすればよいのでしょうか？
 - 11.1 影響の調査
 - 11.2 前方向の調査
 - 11.3 影響の伝播
 - 11.4 影響調査のためのツール
 - 11.5 影響の分析から学ぶこと
 - 11.6 影響スケッチの単純化

### 第12章 1カ所にたくさんの変更が必要ですが、関係するすべてのクラスの依存関係を排除すべきでしょうか？
 - 12.1 割り込み点
	 - 12.1.1 単純な場合
	 - 12.1.2 上位レベルの割り込み点
 - 12.2 絞り込み点で設計を判断する
 - 12.3 絞り込み点の落とし穴

### 第13章 変更する必要がありますが、どんなテストを書けばよいのかわかりません
 - 13.1 仕様化テスト
 - 13.2 クラスの仕様を明らかにする
 - 13.3 狙いを定めたテスト
 - 13.4 仕様化テストを書くための経験則

### 第14章 ライブラリへの依存で身動きが取れません

### 第15章 私のアプリケーションはAPI呼び出しだらけです

### 第16章　変更できるほど十分に私はコードを理解していません
 - 16.1 メモを取る／スケッチを描く
 - 16.2 印を付ける
	 - 16.2.1 貴務の分割
	 - 16.2.2 メソッドの構造の理解
	 - 16.2.3 メソッドの抽出
	 - 16.2.4 変更の影響の理解
 - 16.3 試行リファクタリング
 - 16.4 使用していないコードを削除する

### 第17章 私のアプリケーションには構造がありません
 - 17.1 システムのストーリーを話す
 - 17.2 白紙のCRC
 - 17.3 会話の吟味

### 第18章
 - 18.1 クラスの命名規約
 - 18.2 テストコードの配置

### 第19章 自分のテストコードが邪魔になっています

### 第20章 私のプロジェクトはオブジェクト指向ではありませんが、どうすれば安全に変更できるでしょうか？
 - 19.1 簡単なケース
 - 19.2 困難なケース
 - 19.3 新しい振る舞いの追加…
 - 19.4 オブジェクト指向の長所の活用
 - 19.5 すべてはオブジェクト指向

### 第20章このクラスは大きすぎて、もうこれ以上大きくしたくありません
 - 20.1 責務の把握
 - 20.2 その他の技法
 - 20.3 先へ進む
	 - 20.3.1 戦略
	 - 20.3.2 戦術
 - 20.4 クラスの抽出後

### 第21章 同じコードをいたるところで変更しています
 - 21.1 最初のステップ

### 第22章 モンスターメソッドを変更する必要がありますが、テストを書くことができません
 - 22.1 モンスターの変種
	 - 22.1.1 箇条書きメソッド
	 - 22.1.2 錯乱メソッド
 - 22.2 自動リファクタリング機能でモンスターに立ち向かう
 - 22.3 手作業によるリファクタリングに挑戦
	 - 22.3.1 検出用変数の導入
	 - 22.3.2 理解している部分の抽出
	 - 22.3.3 依存関係の落ち拾い
	 - 22.3.4 メソッドオブジェクトの取り出し
 - 22.4 戦略
	 - 22.4.1 骨組みメソッド
	 - 22.4.2 処理シーケンスの発見
	 - 22.4.3 まず現在のクラス内で抽出する
	 - 22.4.4 小さい部分の抽出
	 - 22.4.5 抽出をやり直す覚悟

### 第23章 どうすれば何も壊していないことを確認できるでしょうか？
 - 23.1 超集中編集
 - 23.2 単一目的の編集
 - 23.3 シグネチャの維持
 - 23.4 コンパイラまかせ
 - 23.5 ペアプログラミング

### 第24章 もうウンザリです。何も改善できません

## 第3部 依存関係を排除する手法

### 第25章 依存関係を排除する手法
 - 25.1 パラメータの適合
 - 25.2 メソッドオブジェクトの取り出し
 - 25.3 定義の補完
 - 25.4 グローバル参照のカプセル化
 - 25.5 静的メソッドの公開
 - 25.6 呼び出しの抽出とオーバーライド
 - 25.7 Factory Methodの抽出とオーバーライド
 - 25.8 getメソッドの抽出とオーバーライド
 - 25.9 実装の抽出
 - 25.10 インタフェースの抽出
 - 25.11 インスタンス委譲の導入
 - 25.12 静的setメソッドの導入
 - 25.13 リンクによる置き換え
 - 25.14 コンストラクタのパラメータ化
 - 25.15 メソッドのパラメータ化
 - 25.16 パラメータのプリミティブ化
 - 25.17 メソッドと変数の引き上げ
 - 25.18 依存関係の押し出し
 - 25.19 関数ポインタによる関数の置き換え..
 - 25.20 getメソッドによるグローバル参照の置き換え
 - 25.21 サブクラス化とメソッドのオーバーライド
 - 25.22 インスタンス変数の入れ替え
 - 25.23 テンプレートによる再定義
 - 25.24 テキストによる再定義

付録A リファクタリング
A.1 メソッドの抽出

付録B 用語集

訳者あとがき

索引

著者紹介

訳者紹介